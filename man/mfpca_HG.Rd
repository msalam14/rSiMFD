% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rSiMFD.R
\name{mfpca_HG}
\alias{mfpca_HG}
\title{Performs multivariate functional principal component analysis on subject-
specific means for a given iMVFD. This is a function used in the simulation 
study only for estimating the variances of scores involved with subject-
specific deviation.}
\usage{
mfpca_HG(fDATA, indxJ, spat_indx, funARG, PVE, center = FALSE)
}
\arguments{
\item{fDATA}{is a list of observed functional data. Each element represents 
one component of the multivariate function}

\item{indxJ}{is a vector of length n that has elements represent m_i}

\item{spat_indx}{is a L by 2 matrix contains spatial locations}

\item{funARG}{is vector of sampled points where functional data were observed. 
This can be generalized for sparse functional data. However this version 
is only for dense functional data. Also all the functions are observed at 
identical sampled point.}

\item{PVE}{is a vector of length 2 for percentage of variation explained. 
The first is used for fpca of each functional variable. The second is for 
eigen decomposition of scores from each of the}

\item{center}{is a logical vector of length 1 indicates whether the 
functional data need centering by the sample mean}
}
\value{
a list with following objects:
\itemize{
 \item n : number of subjects in the data
 \item p : number of features in the data
 \item funARG : functional grid where FD were observed
 \item mFDATA : mean of each feature where center=TRUE
 \item SubEigenF : estimated eigenfunctions
 \item Zeta : projection of subject means on to the estimated eigenfunctions
}
}
\description{
Performs multivariate functional principal component analysis on subject-
specific means for a given iMVFD. This is a function used in the simulation 
study only for estimating the variances of scores involved with subject-
specific deviation.
}
\examples{
# Load required package
library(mvtnorm)

# Example parameters
n <- 25
m_i <- rep(4, n)

# Spatial index: 5x5 grid on [0,1]^2
spat_indx <- as.matrix(expand.grid(seq(0, 1, length.out = 5),
                                   seq(0, 1, length.out = 5)))

# Functional argument (time points)
funARG <- seq(0, 1, length.out = 20)

# Mean function: p = 2 dimensional
meanFUN <- function(t) {
  c(sin(2 * pi * t), cos(2 * pi * t))
}

# Basis functions for p = 2
basisFUN <- list(
  function(t) cbind(sin(pi * t), cos(pi * t)),
  function(t) cbind(sin(2 * pi * t), cos(2 * pi * t))
)

# Variance of zeta (2 components)
zetaVAR <- c(1, 0.5)

# Correlation functions for xi
corrFUN <- list(
  function(r) corSpatialVal(r,d=0.3,nugget = 0.15,type = "exponential"),      # exponential correlation
  function(r) corSpatialVal(r,d=0.45,nugget = 0.05,type = "spherical") # slower decay
)

# Spatial variance and noise
spatVAR <- c(1, 0.5)
sigma2 <- 0.1

# Generate data
set.seed(123)
sim_data <- rsimvFD(n, m_i, spat_indx, funARG,
                    meanFUN, basisFUN, zetaVAR,
                    corrFUN, spatVAR, sigma2)

fit_mfpca<-mfpca_HG(fDATA=sim_data$data,
         indxJ=m_i,
         spat_indx=spat_indx,
         funARG=funARG,
         PVE=c(0.95,0.95),
         center=TRUE)

# Estimated variances of scores associated to the eigenfunctions from mfpca
apply(fit_mfpca$Zeta,2,var)  
  
}
